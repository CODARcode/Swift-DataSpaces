
= Swift-DataSpaces Integration

The point of this module is to demonstrate tight integration between Swift/T and DataSpaces, allowing Swift/T workflows to access DataSpaces efficiently through the DataSpaces C API.

== Architecture

=== Strategy

. Swift/T can call directly into C functions if they have a Tcl wrapper
. We use SWIG to generate these wrappers
. We then can write Tcl programs that use DataSpaces
. We can produce nice Swift/T functions that use the Tcl functions
. Then we can write Swift/T workflows that access DataSpaces

=== Process layout

. The DataSpaces servers and Swift/T run as separate MPI programs
. All Swift/T processes are considered DataSpaces clients, and all of them load/initialize the DataSpaces library.  However, only the workers will actually use the DataSpaces API to move data.

== File index

SDS = Swift-DataSpaces

=== Swift module

+sds.c+::
Light wrapper around the DataSpaces init/put/get/finalize calls.  These functions simplify the API for SWIG

+sds.h+::
The header for sds.c processed by SWIG

+sds.i+::
SWIG input file- points to sds.h , creates Tcl extension wrapper sds_wrap.c

+sds.swift+::
Swift/T wrappers for the Tcl functions

=== Build/package system

+Makefile+::
Compiles sds.c and sds_wrap.c into libsds.so , which links against Tcl and DataSpaces.  Creates a loadable Tcl package.

+make-package.tcl+::
Makes the Tcl package

+pkgIndex.tcl+::
The Tcl package index

=== Tests

==== Tcl

+run-test-ds-tcl.sh+::
Runs the pure Tcl test test-ds.tcl

+test-ds.tcl+::
Tests the Tcl sds package

==== Swift/T

+run-test-sds.sh T+::
Runs the Swift/T test test-sds-T.swift

+test-sds-1.swift+::
A simple Swift/T put/get test

+test-sds-2.swift+::
A simple Swift/T file put/get test

+make-data.sh+::
Data file maker: see header for usage

== Installation

=== Cori

==== DataSpaces

. Obtain DataSpaces 1.6.5 from Wozniak or Davis.
. Configure with:
+
----
./configure CC=cc FC=ftn CFLAGS=-fPIC \
   --enable-drc --prefix=$HOME/dataspaces-1.6.5
----
. May turn on DEBUG in dart/debug.h

==== Swift/T

. There is a Swift/T branch called "dataspaces" that launches the
  DataSpaces server when the Turbine job starts.   This uses environment
  variables DS_SERVERS and DS_CLIENTS as described in the <<Plan>>
. There is a public installation of Swift/T + DataSpaces at:
+
----
~wozniak/Public/sfw/compute/swift-t-ds
----
. You need Swift/T features as of 2017/12/05 (https://github.com/swift-lang/swift-t/commit/a5a9860afd9e178f0d056f4d7168964b8c9b9ba7[a5a9860a]). +
  If Swift/T is already installed, just pull and do +make install+
  for ADLB and Turbine.
. Or use Swift/T as described in the http://swift-lang.github.io/swift-t/sites.html#_cori[Swift/T Cori notes]

=== SDS

==== Plan

. Edit Makefile to set Tcl and DataSpaces locations
. Run +make+
. Run +./run-test-ds.sh+
. Run +./run-test-sds.sh 1+

==== Cori

Run +./build-cori.sh+

== Usage transcripts

=== Swift/T test

This test automatically starts/kills the server

----
$ ./run-test-sds.sh 1
Running Swift/T test 1 ...
dataspaces_server running: DS_SERVER_PID=19507
[0] sds_kv_put: key1=value1
[1] sds_kv_get: key1 (100)
[1] sds_kv_got: key1=value1
[0] trace: s: ,value1
killing dataspaces_server
----

NOTE: We use the location syntax to force the put and get tasks to
run on separate ranks.  You can simply comment out this syntax
and the workflow will still work.

=== Pure Tcl test

In one shell, do:
----
$ dataspaces_server -s 1 -c 2
----

Then, in another shell, do:
----
$ ./run-test-ds-tcl.sh
----

NOTE: Kill and restart the server after each test.

== Implementation notes

=== Initialization

. When Swift/T starts, the workflow does: import sds;
. This loads the Tcl package sds
. At startup, the sds.tcl file is read.  This:
.. Duplicates the ADLB communicator
.. Requests Turbine call proc sds_init_tcl at startup (Swift/T feature f202c037)
... This calls sds.c:sds_init()
... This calls dspaces_init()

=== Functions

. We currently have two simplified functions in Swift/T: sds_kv_put() and sds_kv_get(), which are string-string put/get functions.
. The Swift/T interfaces are in sds.swift
. As shown, these call the sds_kv_put/sds_kv_get Tcl functions
. These are generated by SWIG from sds.h/sds.i
. These call sds.c:sds_kv_put()/sds_kv_get()
. These call dspaces_put()/dspaces_get()

== Benchmarks for report

[[plan]]
=== Plan

Use Swift/T branch "dataspaces"

We hacked turbine.pbs.m4 to use these variables:

* PROCS is total processes in the allocation
* DS_SERVERS is the dataspaces_server -s argument
* DS_CLIENTS is the total number of Swift/T processes +
    and the dataspaces_server -c argument

* The bench-*.swift scripts use DataSpaces
* The cntrl-*.swift scripts use the FS

=== Usage

Set

----
$ export PROCS=3 DS_SERVERS=1 ; export DS_CLIENTS=$(( PROCS-DS_SERVERS ))
----
then run with:
----
$ ./bench-blues.sh bench-2
# or
$ ./bench-cori.sh bench-2
----
or the whatever Swift script you want to run instead of bench-2.swift .

To collect the output data, do:
----
$ ./data.sh $( cat turbine-directory.txt )/output.txt
----
or whatever output file you want to scan.

=== Note about data size

* Bench/Cntrl 3a uses 1KB data
* Bench/Cntrl 3b uses 1MB data
